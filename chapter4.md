# Chapter 4

## 4.1 Intro

### What is an Implementation of MIPS

An implementation of MIPS refers to the actual hardware design and construction of a processor that executes instructions from the MIPS instruction set architecture

Implementing MIPS involves designing and building the various components of a processor, such as the datapath, control unit, memory interface, and input/output interface, to execute instructions according to the MIPS ISA. Here are some key components and aspects of a MIPS implementation:

1. **Datapath**: The datapath consists of various functional units, such as the ALU, register file, and memory interfaces, connected by buses. The design of the datapath determines how instructions are executed and how data flows through the processor.

2. **Control Unit**: The control unit generates control signals that coordinate the operation of the datapath components based on the current instruction being executed. It decodes instruction opcodes and determines the sequence of operations needed to execute the instruction.

3. **Registers**: The MIPS ISA includes a set of 32 general-purpose registers (labeled \$0 to \$31) that store data for processing. Implementing these registers involves designing a register file that can read from and write to these registers efficiently.

4. **Memory Interface**: The processor needs to interface with memory to fetch instructions and data. This involves designing an interface to access instruction memory and data memory, typically implemented as separate components.

5. **Instruction Fetch**: The processor fetches instructions from memory based on the value of the program counter (PC). The instruction fetch unit retrieves the instruction from memory and increments the PC to point to the next instruction.

6. **Instruction Execution**: The ALU performs arithmetic and logical operations specified by instructions. The execution unit also includes components for handling branch instructions and jump instructions.

7. **Control Signals**: Various control signals are generated by the control unit to control the multiplexers, ALU operations, register file operations, and memory operations. These signals ensure that instructions are executed correctly and in the correct sequence.

8. **Pipeline**: In advanced implementations, MIPS processors can be pipelined to improve performance. Pipelining allows multiple instructions to be in different stages of execution simultaneously, increasing throughput.

### A basic MIPS implementation

We will be examining an implementation that includes a subset of the core MIPS instruction set:

- The memory-reference instructions load word (lw) and store word (sw)
- The arithmetic-logical instructions add, sub, AND, OR, and slt
- The instructions branch equal (beq) and jump (j), which we add last
This illustrates the key principles used in creating a datapath and designing the control. The implementation of the remaining instructions is similar.

### Overivew
We looked at the core MIPS instructions, including the integer arithmetic-logical instructions, the memory-reference instructions, and the branch instructions.<br>
Much of what needs to be done to implement these instructions is the same, independent of the exact class of instruction.<br>
For every instruction, the first two steps are identical:

1. Send the program counter (PC) to the memory that contains the code and fetch the instruction from that memory.
2. Read one or two registers, using fields of the instruction to select the registers to read. For the load word instruction, we need to read only one register, but most other instructions require reading two registers.

The 3rd step is often very similar too. For example, all instruction classes, except jump, use the arithmetic-logical unit (ALU) after reading the registers. 
- The memory-reference instructions use the ALU for an address calculation,<br>the arithmetic-logical instructions for the operation execution,<br>and branches for comparison.

After using the ALU, the actions required to complete various instruction classes differ. 
- A memory-reference instruction will need to access the memory either to read data for a load or write data for a store.
- An arithmetic-logical or load instruction must write the data from the ALU or memory back into a register.
- Lastly, for a branch instruction, we may need to change the next instruction address based on the comparison; otherwise, the PC should be incremented by 4 to get the address of the next instruction.

![Alt text](https://github.com/mayjspencer/Architecture-notes/blob/main/ALU1.png?raw=true)

1. **Instruction Fetch**: The first step in executing any instruction is fetching it from memory. This is done using the Program Counter (PC) to determine the memory address of the instruction.

2. **Register Read**: Most instructions require reading one or two registers. The instruction specifies which registers to read.

3. **ALU Operations**: After reading registers, most instructions use the Arithmetic Logic Unit (ALU) for some operation. This could be an arithmetic operation, logical operation, or a comparison for branches.

4. **Memory Access**: Memory-reference instructions (like load and store) access data memory. The ALU is used to calculate the memory address.

5. **Write Back**: The result of an ALU operation or data from memory is often written back to a register.

6. **Branch Handling**: For branch instructions, the ALU is used for comparison. Depending on the result, the next instruction address is either calculated by adding an offset to the current PC or by directly setting it to a new address.

7. **Control Unit**: A control unit interprets the instruction and generates control signals for various components of the processor (ALU, registers, memory, etc.) to perform the required operations.

8. **Multiplexors**: Multiplexors are used to select between different data sources or operations based on the type of instruction being executed.

9. **Clock Cycle**: Initially, the text describes a simple implementation where each instruction takes a single clock cycle to complete. This is not efficient for all instructions but is a starting point for understanding the basic concepts.

The text also mentions that this basic design is a foundation for more complex implementations, where instructions may take multiple clock cycles and where pipelining is used to improve performance.


## 4.2 Logic Design Conventions

### Combinational vs Sequential

- **Combinational Elements**: These elements operate on data values and produce outputs based solely on their current inputs. The ALU is an example of a combinational element because it produces the same output for the same set of inputs and has no internal storage.

- **State Elements**: These elements contain internal storage and are not solely dependent on their inputs. Examples include registers, memories, and flip-flops. State elements retain their values even when the power is turned off and completely characterize the computer's state.

- **Inputs and Outputs of State Elements**: State elements have at least two inputs (data value to be written and clock signal) and one output (the value that was written in an earlier clock cycle). The clock signal determines when the data value should be written into the state element.

- **Sequential Logic**: Components that contain state are also known as sequential logic elements because their outputs depend on both their inputs and the internal state. For example, the output from a register depends on both the data value supplied to it and on what was written into the register previously.

### Clocking Methodology

- **Clocking Methodology**: It defines when signals can be read and when they can be written, ensuring hardware predictability. It specifies the timing of reads and writes to avoid conflicts that could lead to unpredictable behavior.

- **Edge-Triggered Clocking**: This methodology updates values in sequential logic elements only on a clock edge, which is a quick transition from low to high or vice versa. Combinational logic must have inputs from and outputs to state elements, ensuring that outputs are stable and valid for the next clock cycle.

- **Inputs and Outputs in Edge-Triggered Clocking**: Inputs to combinational logic are values stored in state elements from the previous clock cycle. Outputs from combinational logic are written into state elements and become stable and valid for the following clock cycle.

- **Importance of Clocking Methodology**: Clocking methodologies, like edge-triggered clocking, are crucial for maintaining the integrity and predictability of data flow within a computer system. They ensure that data is read and written at the appropriate times, preventing conflicts and ensuring correct operation of the hardware.

### Clock Cycle Walkthrough
To explain and summarize:

- **First Rising Clock Edge**: Both state elements are written with new values on this edge. This means that any data stored in these elements is updated based on the inputs they receive.

- **Propagation of Values**: When a new value is written into state element 1, it triggers a series of calculations or operations in the combinational logic. This means that the combinational logic processes the input it receives from state element 1 and produces an output based on this input. This output is then passed to state element 2.

- **Combinational Logic and Memory**: Combinational logic does not have any memory. This means that its output at any given moment is solely determined by its current input. It doesn't "remember" past inputs or outputs; each output is a direct result of the current input.

- **Stable Values**: For the system to work correctly, the new value computed by the combinational logic must be stable before it enters state element 2. A value is considered stable when it has settled and no longer changes. This ensures that when the new value is latched into state element 2 on the next rising clock edge, it is a reliable and accurate representation of the output from the combinational logic.

- **Timing Considerations**: The new value computed by the combinational logic must be stable and ready to enter state element 2 well before the next rising clock edge. This is crucial for ensuring that the updated data is available and stable for the next clock cycle.

- **Clock Cycle Length**: The time required for signals to propagate from state element 1, through the combinational logic, and to state element 2 defines the length of the clock cycle. This length determines the speed at which the computer can operate reliably.

### Control Signals and Definitions

1. **Write Control Signal**: In the context of updating state elements (like registers or memory) in a digital system, a write control signal is used to indicate when a new value should be written into a state element. This signal is typically synchronized with the clock signal, which determines the timing of operations in the system.

2. **Clock Signal**: The clock signal is a periodic signal that oscillates between two voltage levels (usually 0 and 1) and is used to synchronize the operations of the digital system. State elements are typically updated on the rising or falling edge of the clock signal, depending on the specific design.

3. **Clock Edge**: State elements are updated only when a clock edge occurs (either rising or falling edge, depending on the design). The write control signal must be asserted (logically high) at the same time as the clock edge for the update to occur.

4. **Control Signal**: A control signal is a signal used in digital systems to control the operation of various components, such as multiplexors or functional units. It determines which inputs are selected or how a unit should operate.

5. **Asserted and Deasserted Signals**: When a signal is asserted, it means that the signal is logically high or true. Conversely, when a signal is deasserted, it means that the signal is logically low or false.

For the 32-bit MIPS architecture, most state and logic elements handle 32-bit data.<br>Buses, which are wider signals, are shown with thicker lines.<br>Sometimes, we combine buses to form a wider bus, indicated by labels on the bus lines.<br>Arrows show the direction of data flow between elements.<br>Control signals are distinguished from data signals using color.

## 4.3 Building a Datapath

### What is a datapath?
A datapath is a fundamental component of a computer's architecture that is responsible for executing instructions. It consists of all the hardware components in a processor that are involved in executing instructions, including registers, ALU (Arithmetic Logic Unit), and the interconnections between them. The datapath is responsible for processing data and performing arithmetic and logical operations specified by the instructions.

In a simplified view, the datapath can be thought of as a series of stages through which data flows, with each stage performing a specific operation on the data. These stages typically include fetching instructions from memory, decoding instructions to determine the operation to be performed, reading data from registers, performing the operation using the ALU, and writing the result back to registers or memory.

### Learn Datapaths by Datapath Elements
First, examine the major components required to execute each class of MIPS instructions. Let's start at the top by looking at which datapath elements each instruction needs.When we show the datapath elements, we will also show their control signals.

<strong>Datapath element</strong>: A datapath element is a hardware component within a processor that processes or manipulates data.

It typically includes components like registers, ALUs (Arithmetic Logic Units), and multiplexers, and is responsible for executing instructions according to the processor's architecture.

The datapath elements work together to fetch, decode, execute, and write back data as part of the instruction execution process.

### What we need
The first element we need is a memory unit to store the instructions of a program and supply instructions given an address.

The program counter (PC), is a register that holds the address of the current instruction. 

Lastly, we will need an adder to increment the PC to the address of the next instruction. This adder, which is combinational, can be built from the ALU simply by wiring the control lines so that the control always specifies an add operation. We will draw such an ALU with the label Add to indicate that it has been permanently made an adder and cannot perform the other ALU functions.

![Alt text](https://github.com/mayjspencer/Architecture-notes/blob/main/ALU2.png?raw=true)

### Why we need them

1. **Instruction Memory (IM)**: Instructions need to be stored somewhere in the processor's memory so that they can be fetched and executed. The IM provides a way to access instructions based on the address provided by the PC.

2. **Program Counter (PC)**: The PC keeps track of the address of the next instruction to be executed. After fetching an instruction, the processor needs to know where to find the next instruction in memory. The PC is updated to point to the next instruction, typically by incrementing its value.

3. **Adder**: The adder is used to increment the PC value to point to the next instruction. Since instructions in MIPS are typically 4 bytes long and stored sequentially in memory, adding 4 to the current PC value gives the address of the next instruction.

Together, these elements form the basic fetch-execute cycle of a processor, where instructions are fetched from memory using the PC, the PC is updated to point to the next instruction, and the fetched instruction is executed.

### R-Type Instructions

Now let's consider the R-format instructions. They all read two registers, perform an ALU operation on the contents of the registers, and write the result to a register.

We call these instructions either R-type instructions or arithmetic-logical instructions.

Includes: add, sub, AND, OR, and slt, 

Example: add $t1, $t2, $t3, which reads $t2 and $t3 and writes $t1.

#### Register File: state element
The processor's 32 general-purpose registers are stored in a structure called a register file.

A register file is a collection of registers in which any register can be read or written by specifying the number of the register in the file. 

The register file contains the register state of the computer. In addition, we will need an ALU to operate on the values read from the registers.

#### How to read 2 words and write 1 (R-Type)
   - For reading data words: Need inputs to specify the register number to be read and outputs to carry the value read from the registers.
   - For writing data words: Need inputs to specify the register number to be written and to supply the data to be written into the register.

#### Register File Operation
   - Reading: The register file always outputs the contents of the registers corresponding to the Read register inputs.
   - Writing: Controlled by the write control signal, which must be asserted for a write to occur at the clock edge.

#### Register File Design
   - Contains all the registers and has two read ports and one write port.
   - Reads are straightforward, but writes must be explicitly indicated by asserting the write control signal.
   - Writes are edge-triggered, so all write inputs must be valid at the clock edge.
   - Inputs carrying the register number are 5 bits wide, and lines carrying data values are 32 bits wide.

#### ALU Operation
   - Controlled with the ALU operation signal, which is 4 bits wide.
   - The Zero detection output of the ALU is used for implementing branches, while the overflow output is needed for exceptions later on.

![Alt text](https://github.com/mayjspencer/Architecture-notes/blob/main/ALU3.png?raw=true)

Example:

- The register file always outputs the data in registers corresponding to the two input read addresses. Ex: The data (488 and 999) in registers 7 and 30 is read and output.
- A write occurs on a rising clock edge if RegWrite is 1. Ex: Register 30's data can be overwritten with new data (665) on a rising clock edge.

- Item b in the animation above shows the ALU, which takes two 32-bit inputs and produces a 32-bit result, as well as a 1-bit signal if the result is 0. There is a 4-bit control signal of the ALU

### Load and Store Word:
Next, consider the MIPS load word and store word instructions

General form: lw $t1, offset_value($t2)    OR    sw $t1, offset_value($t2).

These instructions compute a memory address by adding the base register, which is $t2, to the 16-bit signed offset field contained in the instruction. 

Store: the value to be stored must also be read from the register file where it resides in $t1.

Load: the value read from memory must be written into the register file in the specified register, which is $t1. 

Thus, we will need both the register file and the ALU from the animation above.

In addition, we will need a unit to sign-extend the 16-bit offset field in the instruction to a 32-bit signed value, and a data memory unit to read from or write to. 

The data memory must be written on store instructions; hence, data memory has read and write control signals, an address input, and an input for the data to be written into memory.

##### The two units needed to implement loads and stores, in addition to the register file and ALU, are the data memory unit and the sign extension unit

![Alt text](https://github.com/mayjspencer/Architecture-notes/blob/main/ALU4.png?raw=true)

### The beq instruction
The beq instruction has three operands, two registers that are compared for equality, and a 16-bit offset used to compute the branch target address relative to the branch instruction address. 

We must compute the branch target address by adding the sign-extended offset field of the instruction to the PC.<br>The branch datapath must do two operations: compute the branch target address and compare the register contents.

1. **Instruction Format**: `beq $t1, $t2, offset`
   - `$t1` and `$t2` are the registers to compare.
   - `offset` is a 16-bit signed immediate value, representing the branch target address relative to the address of the next instruction.

2. **Branch Target Address Calculation**:
   - The base for the branch address calculation is the address of the instruction following the branch, which is PC + 4.
   - The offset field is shifted left by 2 bits to convert it to a word offset.

3. **Branch Outcome**:
   - If the operands in `$t1` and `$t2` are equal, the branch is taken, and the PC becomes the branch target address.
   - If the operands are not equal, the PC is incremented as usual, and the branch is not taken.

4. **Datapath for `beq` Instruction**:
   - The datapath for `beq` includes a sign extension unit and an adder to compute the branch target address.
   - The ALU is used to compare the register contents. The Zero output of the ALU is used to determine if the operands are equal.

5. **Jump Instruction**:
   - The jump (`j`) instruction replaces the lower 28 bits of the PC with the lower 26 bits of the instruction shifted left by 2 bits.

### Creating a Single Datapath

![Alt text](https://github.com/mayjspencer/Architecture-notes/blob/main/ALU5.png?raw=true)
1. **Shared Components**:
   - Single Register File: The datapath uses a single register file to store and retrieve data. Both instruction types use this register file for operand access and result storage.
   - Single ALU: There is a single ALU in the datapath that performs arithmetic and logical operations. Both instruction types use this ALU for computation.

2. **Multiplexers**:
   - ALU Input Selection: Since memory-reference instructions use the sign-extended offset as one of the ALU inputs, while R-type instructions use a register value, a multiplexer is placed at the ALU input to select between these two sources.
   - Register File Data Input Selection: Similarly, a multiplexer is placed at the data input to the register file to select between the ALU result (for R-type instructions) and the memory data (for load instructions).

3. **Control Signals**:
   - Control signals are used to select the appropriate inputs for the ALU and the register file based on the instruction being executed.
   - These control signals ensure that the datapath correctly handles both types of instructions without conflicts or errors.

4. **Overall Design**:
   - By carefully designing the datapath with multiplexers and control signals, it becomes capable of executing both memory-reference and arithmetic-logical instructions efficiently in a single clock cycle.





.

.

.

.

.

.

.

.

.

.
